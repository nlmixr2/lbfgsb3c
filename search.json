[{"path":"https://nlmixr2.github.io/lbfgsb3c/articles/lbfgsb3c.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"lbfgsb3c: Using the 2011 version of L-BFGS-B.","text":"2011 authors L-BFGSB program published correction update 1995 code. latter basis L-BFGS-B method optim() function base-R. package lbfgsb3 wrapped updated code using .Fortran call removing large number Fortran output statements. Matthew Fidler used Fortran code Rcpp interface produce package lbfgsb3c function lbfgsb3c() returns object similar base-R optim() optimx::optimr(). Subsequently, fine example collaborations made R useful, merged functionality package lbfgsb3 lbfgsb3c, explained vignette. Note document intended primarily document efforts check differences variants code rather expository.","code":""},{"path":"https://nlmixr2.github.io/lbfgsb3c/articles/lbfgsb3c.html","id":"provenance-of-the-r-optiml-bfgs-b-and-related-solvers","dir":"Articles","previous_headings":"Abstract","what":"Provenance of the R optim::L-BFGS-B and related solvers","title":"lbfgsb3c: Using the 2011 version of L-BFGS-B.","text":"base-R code lbfgsb.c (writing R-3.5.2/src/appl/) commented: paper Byrd et al. (1995a) builds Lu et al. (1994). number workers followed-work, R code packages seem largely stayed codes derived original papers. Though date paper 1995, ideas embodies around decade half least, particular Nocedal80 LiuN89. definitive Fortran code published Zhu et al. (1997). available toms/778.zip www.netlib.org. side--side comparison main subroutines two downloads Netlib unfortunately shows lot differences. tried determine affect performance simply cosmetic. seriously perhaps, deficiencies code(s), 2011 Nocedal’s team published Fortran code corrections (Morales Nocedal (2011)). Since R code predates , prepared package lbfgsb3 (Nash et al. (2015)) wrap Fortran code. However, discover test cases optim::L-BFGS-B lbfgsb3 different, though confess running limited tests. , fact, vignette. 2016, Fields Institute optimization conference Toronto 70th birthday Andy Conn. sheer serendipity, Nocedal attend conference, sat next conference dinner. asked key changes, said important one fix computation machine precision, always correct 1995 code. Since R gets number .Machine$double.eps, offending code irrelevant. Within Morales Nocedal (2011), also reported improvement subspace minimization applied cases bounds constraints. Since tests applied impose constraints, reasonable observed performance differences base-R optim code lbfsgb3 package. appropriate tests welcome, agenda. Besides ACM TOMS code, two related codes Northwestern team NETLIB: http://netlib.org/opt/lbfgs_um.shar unconstrained minimization, http://netlib.org/opt/lbfgs_bcm.shar handles bounds constrained problems. attached references Liu Nocedal (1989) Byrd et al. (1995b) respectively, likely reflecting effort required implement constraints. unconstrained code converted C leadership Naoaki Okazaki (see http://www.chokkan.org/software/liblbfgs/, fork https://github.com/MIRTK/LBFGS). wrapped R Coppola, Stewart, Okazaki (2014) lbfgs package. can called optimx::optimr(). Using Rcpp (see Eddelbuettel François (2011)) Fortran code package lbfgs3, Matthew Fidler developed package lbfgsb3c (Fidler et al. (2018)). provides standard call return lbfgsb3 Fidler unified two packages released name lbfgsb3c.","code":"/* l-bfgs-b.f -- translated by f2c (version 19991025).    From ?optim:   The code for method ‘\"L-BFGS-B\"’ is based on Fortran code by Zhu,   Byrd, Lu-Chen and Nocedal obtained from Netlib (file 'opt/lbfgs_bcm.shar')    The Fortran files contained no copyright information.    Byrd, R. H., Lu, P., Nocedal, J. and Zhu, C.  (1995) A limited   memory algorithm for bound constrained optimization.   \\emph{SIAM J. Scientific Computing}, \\bold{16}, 1190--1208. */"},{"path":"https://nlmixr2.github.io/lbfgsb3c/articles/lbfgsb3c.html","id":"functions-in-package-lbfgsb3c","dir":"Articles","previous_headings":"Abstract","what":"Functions in package lbfgsb3c","title":"lbfgsb3c: Using the 2011 version of L-BFGS-B.","text":"really one optimizer function package, may called four (4) names: lbfgsb3c() uses Rcpp (Eddelbuettel (2013), Eddelbuettel François (2011), Eddelbuettel Balamuta (2017)) streamline call underlying Fortran. base function used. lbfgsb3x() alias lbfgsb3c(). using name , kept alias avoid edit test scripts. lbfgsb3, imitates .Fortran call compiled 2011 Fortran code. object returned routine equivalent object returned base-R optim() optimx::optimr(). Instead, includes structure info contains detailed diagnostic information Fortran code. users, interest, recommend use function needing examine optimization carried . lbfgsb3f() alias lbfsgb3(). recommend using lbfsgb3c() call uses.","code":""},{"path":"https://nlmixr2.github.io/lbfgsb3c/articles/lbfgsb3c.html","id":"candlestick-function","dir":"Articles","previous_headings":"Abstract > Functions in package lbfgsb3c","what":"Candlestick function","title":"lbfgsb3c: Using the 2011 version of L-BFGS-B.","text":"","code":"# candlestick function # J C Nash 2011-2-3 cstick.f<-function(x,alpha=100){   x<-as.vector(x)   r2<-crossprod(x)   f<-as.double(r2+alpha/r2)   return(f) }  cstick.g<-function(x,alpha=100){   x<-as.vector(x)   r2<-as.numeric(crossprod(x))   g1<-2*x   g2 <- (-alpha)*2*x/(r2*r2)   g<-as.double(g1+g2)   return(g) } library(lbfgsb3c) nn <- 2 x0 <- c(10,10) lo <- c(1, 1) up <- c(10,10) print(x0) ## [1] 10 10 ## c2o <- opm(x0, cstick.f, cstick.g, lower=lo, upper=up, method=meths, control=list(trace=0)) ## print(summary(c2o, order=value)) c2l1 <- lbfgsb3c(x0, cstick.f, cstick.g, lower=lo, upper=up) c2l1 ## $par ## [1] 2.236068 2.236068 ##  ## $grad ## [1] -1.205926e-08 -1.205926e-08 ##  ## $value ## [1] 20 ##  ## $counts ## [1] 15 15 ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH\" ## meths <- c(\"L-BFGS-B\", \"lbfgsb3c\", \"Rvmmin\", \"Rcgmin\", \"Rtnmin\") ## require(optimx)  ## cstick2a <- opm(x0, cstick.f, cstick.g, method=meths, upper=up, lower=lo, control=list(kkt=FALSE)) ## print(summary(cstick2a, par.select=1:2, order=value)) lo <- c(4, 4) ## c2ob <- opm(x0, cstick.f, cstick.g, lower=lo, upper=up, method=meths, control=list(trace=0)) ## print(summary(c2ob, order=value)) c2l2 <- lbfgsb3c(x0, cstick.f, cstick.g, lower=lo, upper=up) c2l2 ## $par ## [1] 4 4 ##  ## $grad ## [1] 7.21875 7.21875 ##  ## $value ## [1] 35.125 ##  ## $counts ## [1] 4 4 ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL\" ## cstick2b <- opm(x0, cstick.f, cstick.g, method=meths, upper=up, lower=lo, control=list(kkt=FALSE)) ## print(summary(cstick2b, par.select=1:2, order=value))  ## nn <- 100 ## x0 <- rep(10, nn) ## up <- rep(10, nn) ## lo <- rep(1e-4, nn) ## cco <- opm(x0, cstick.f, cstick.g, lower=lo, upper=up, method=meths, control=list(trace=0, kkt=FALSE)) ## print(summary(cco, par.select=1:4, order=value))"},{"path":"https://nlmixr2.github.io/lbfgsb3c/articles/lbfgsb3c.html","id":"extended-rosenbrock-function-from-funconstrain","dir":"Articles","previous_headings":"Abstract > Functions in package lbfgsb3c","what":"Extended Rosenbrock function (from funconstrain)","title":"lbfgsb3c: Using the 2011 version of L-BFGS-B.","text":"","code":"# require(funconstrain) ## not in CRAN, so explicit inclusion of this function # exrosen <- ex_rosen() # exrosenf <- exrosen$fn exrosenf <- function (par) {     n <- length(par)     if (n%%2 != 0) {         stop(\"Extended Rosenbrock: n must be even\")     }     fsum <- 0     for (i in 1:(n/2)) {         p2 <- 2 * i         p1 <- p2 - 1         f_p1 <- 10 * (par[p2] - par[p1]^2)         f_p2 <- 1 - par[p1]         fsum <- fsum + f_p1 * f_p1 + f_p2 * f_p2     }     fsum } # exroseng <- exrosen$gr exroseng <- function (par) {     n <- length(par)     if (n%%2 != 0) {         stop(\"Extended Rosenbrock: n must be even\")     }     grad <- rep(0, n)     for (i in 1:(n/2)) {         p2 <- 2 * i         p1 <- p2 - 1         xx <- par[p1] * par[p1]         yx <- par[p2] - xx         f_p1 <- 10 * yx         f_p2 <- 1 - par[p1]         grad[p1] <- grad[p1] - 400 * par[p1] * yx - 2 * f_p2         grad[p2] <- grad[p2] + 200 * yx     }     grad }  exrosenx0 <- function (n = 20) {     if (n%%2 != 0) {         stop(\"Extended Rosenbrock: n must be even\")     }     rep(c(-1.2, 1), n/2) }   require(lbfgsb3c) ## require(optimx)  ## require(optimx) for (n in seq(2,12, by=2)) {   cat(\"ex_rosen try for n=\",n,\"\\n\")   x0 <- exrosenx0(n)   lo <- rep(-1.5, n)   up <- rep(3, n)   print(x0)   cat(\"optim L-BFGS-B\\n\")   eo <- optim(x0, exrosenf, exroseng, lower=lo, upper=up, method=\"L-BFGS-B\", control=list(trace=0))   print(eo)   cat(\"lbfgsb3c\\n\")   el <- lbfgsb3c(x0, exrosenf, exroseng, lower=lo, upper=up, control=list(trace=0))   print(el) ##    erfg <- opm(x0, exrosenf, exroseng, method=meths, lower=lo, upper=up) ##    print(summary(erfg, par.select=1:2, order=value)) } ## ex_rosen try for n= 2  ## [1] -1.2  1.0 ## optim L-BFGS-B ## $par ## [1] 1 1 ##  ## $value ## [1] 3.844416e-14 ##  ## $counts ## function gradient  ##       51       51  ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH\" ##  ## lbfgsb3c ## $par ## [1] 1.000000 1.000001 ##  ## $grad ## [1]  8.331804e-06 -3.715433e-06 ##  ## $value ## [1] 2.374318e-13 ##  ## $counts ## [1] 61 61 ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH\" ##  ## ex_rosen try for n= 4  ## [1] -1.2  1.0 -1.2  1.0 ## optim L-BFGS-B ## $par ## [1] 1 1 1 1 ##  ## $value ## [1] 7.688835e-14 ##  ## $counts ## function gradient  ##       51       51  ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH\" ##  ## lbfgsb3c ## $par ## [1] 0.9999942 0.9999884 0.9999942 0.9999884 ##  ## $grad ## [1]  4.530933e-06 -8.036816e-06  4.530933e-06 -8.036816e-06 ##  ## $value ## [1] 6.693882e-11 ##  ## $counts ## [1] 75 75 ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH\" ##  ## ex_rosen try for n= 6  ## [1] -1.2  1.0 -1.2  1.0 -1.2  1.0 ## optim L-BFGS-B ## $par ## [1] 1 1 1 1 1 1 ##  ## $value ## [1] 1.153325e-13 ##  ## $counts ## function gradient  ##       51       51  ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH\" ##  ## lbfgsb3c ## $par ## [1] 0.9999986 0.9999973 0.9999986 0.9999973 0.9999986 0.9999973 ##  ## $grad ## [1] -7.930726e-05  3.822476e-05 -7.930726e-05  3.822476e-05 -7.930726e-05 ## [6]  3.822476e-05 ##  ## $value ## [1] 1.708394e-11 ##  ## $counts ## [1] 74 74 ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH\" ##  ## ex_rosen try for n= 8  ## [1] -1.2  1.0 -1.2  1.0 -1.2  1.0 -1.2  1.0 ## optim L-BFGS-B ## $par ## [1] 1 1 1 1 1 1 1 1 ##  ## $value ## [1] 1.537767e-13 ##  ## $counts ## function gradient  ##       51       51  ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH\" ##  ## lbfgsb3c ## $par ## [1] 1.0000000 0.9999999 1.0000000 0.9999999 1.0000000 0.9999999 1.0000000 ## [8] 0.9999999 ##  ## $grad ## [1]  1.878639e-07 -1.259256e-07  1.878639e-07 -1.259256e-07  1.878639e-07 ## [6] -1.259256e-07  1.878639e-07 -1.259256e-07 ##  ## $value ## [1] 4.252944e-15 ##  ## $counts ## [1] 62 62 ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: Parameters differences below xtol\" ##  ## ex_rosen try for n= 10  ##  [1] -1.2  1.0 -1.2  1.0 -1.2  1.0 -1.2  1.0 -1.2  1.0 ## optim L-BFGS-B ## $par ##  [1] 1 1 1 1 1 1 1 1 1 1 ##  ## $value ## [1] 1.922208e-13 ##  ## $counts ## function gradient  ##       51       51  ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH\" ##  ## lbfgsb3c ## $par ##  [1] 0.9999960 0.9999918 0.9999960 0.9999918 0.9999960 0.9999918 0.9999960 ##  [8] 0.9999918 0.9999960 0.9999918 ##  ## $grad ##  [1]  2.568217e-05 -1.687783e-05  2.568217e-05 -1.687783e-05  2.568217e-05 ##  [6] -1.687783e-05  2.568217e-05 -1.687783e-05  2.568217e-05 -1.687783e-05 ##  ## $value ## [1] 8.503449e-11 ##  ## $counts ## [1] 70 70 ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH\" ##  ## ex_rosen try for n= 12  ##  [1] -1.2  1.0 -1.2  1.0 -1.2  1.0 -1.2  1.0 -1.2  1.0 -1.2  1.0 ## optim L-BFGS-B ## $par ##  [1] 1 1 1 1 1 1 1 1 1 1 1 1 ##  ## $value ## [1] 2.306652e-13 ##  ## $counts ## function gradient  ##       51       51  ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH\" ##  ## lbfgsb3c ## $par ##  [1] 0.9999672 0.9999341 0.9999672 0.9999341 0.9999672 0.9999341 0.9999672 ##  [8] 0.9999341 0.9999672 0.9999341 0.9999672 0.9999341 ##  ## $grad ##  [1]  1.161452e-05 -3.865353e-05  1.161452e-05 -3.865353e-05  1.161452e-05 ##  [6] -3.865353e-05  1.161452e-05 -3.865353e-05  1.161452e-05 -3.865353e-05 ## [11]  1.161452e-05 -3.865353e-05 ##  ## $value ## [1] 6.495175e-09 ##  ## $counts ## [1] 66 66 ##  ## $convergence ## [1] 0 ##  ## $message ## [1] \"CONVERGENCE: Parameters differences below xtol\""},{"path":"https://nlmixr2.github.io/lbfgsb3c/articles/lbfgsb3c.html","id":"using-compiled-function-code","dir":"Articles","previous_headings":"Abstract","what":"Using compiled function code","title":"lbfgsb3c: Using the 2011 version of L-BFGS-B.","text":"may use interface described writing R extensions interface compiled code function, see L-BFGS-B, sometimes convenient use compiled code. following example shows done using file jrosen.f. unfortunately found compilation always portable across systems, example presented without execution. example script. Note must file jrosen.f available. executable files different systems use different conventions structures, turned evaluation vignette can built multiple platforms. However, wished provide examples compiled code used. example, Fortran execution actually SLOWER plain R system run.","code":"subroutine rosen(n, x, fval)        double precision x(n), fval, dx        integer n, i        fval = 0.0D0        do 10 i=1,(n-1)           dx = x(i + 1) - x(i) * x(i)           fval = fval + 100.0 * dx * dx           dx = 1.0 - x(i)           fval = fval + dx * dx  10    continue        return        end system(\"R CMD SHLIB jrosen.f\") dyn.load(\"jrosen.so\") is.loaded(\"rosen\") x0 <- as.double(c(-1.2,1)) fv <- as.double(-999) n <- as.double(2) testf <- .Fortran(\"rosen\", n=as.integer(n), x=as.double(x0), fval=as.double(fv)) testf  rrosen <- function(x) {   fval <- 0.0   for (i in 1:(n-1)) {     dx <- x[i + 1] - x[i] * x[i]     fval <- fval + 100.0 * dx * dx     dx <- 1.0 - x[i]     fval <- fval + dx * dx   }   fval }  (rrosen(x0))  frosen <- function(x){   nn <- length(x)   if (nn > 100) { stop(\"max number of parameters is 100\")}   fv <- -999.0   val <- .Fortran(\"rosen\", n=as.integer(nn), x=as.double(x), fval=as.double(fv))   val$fval # NOTE--need ONLY function value returned } # Test the funcion tval <- frosen(x0) str(tval)  cat(\"Run with Nelder-Mead using R function\\n\") mynm <- optim(x0, rrosen, control=list(trace=0)) print(mynm) cat(\"\\n\\n Run with Nelder-Mead using Fortran function\") mynmf <- optim(x0, frosen, control=list(trace=0)) print(mynmf)   library(lbfgsb3c) library(microbenchmark) cat(\"try lbfgsb3c, no Gradient \\n\") cat(\"R function\\n\") tlR<-microbenchmark(myopR <- lbfgsb3c(x0, rrosen, gr=NULL, control=list(trace=0))) print(tlR) print(myopR) cat(\"Fortran function\\n\") tlF<-microbenchmark(myop <- lbfgsb3c(x0, frosen, gr=NULL, control=list(trace=0))) print(tlF) print(myop)"},{"path":[]},{"path":"https://nlmixr2.github.io/lbfgsb3c/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Matthew L Fidler. Author, maintainer. John C Nash. Author. Ciyou Zhu. Author. Richard Byrd. Author. Jorge Nocedal. Author. Jose Luis Morales. Author.","code":""},{"path":"https://nlmixr2.github.io/lbfgsb3c/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Fidler ML, Nash JC, Zhu C, Byrd R, Nocedal J, Morales JL (2023). lbfgsb3c: Limited Memory BFGS Minimizer Bounds Parameters optim() 'C' Interface. R package version 2020-3.2, https://nlmixr2.github.io/lbfgsb3c/.","code":"@Manual{,   title = {lbfgsb3c: Limited Memory BFGS Minimizer with Bounds on Parameters with optim() 'C' Interface},   author = {Matthew L Fidler and John C Nash and Ciyou Zhu and Richard Byrd and Jorge Nocedal and Jose Luis Morales},   year = {2023},   note = {R package version 2020-3.2},   url = {https://nlmixr2.github.io/lbfgsb3c/}, }"},{"path":"https://nlmixr2.github.io/lbfgsb3c/index.html","id":"libfgsb3c-interface-from-c","dir":"","previous_headings":"","what":"Limited Memory BFGS Minimizer with Bounds on Parameters with\n        optim() C Interface","title":"Limited Memory BFGS Minimizer with Bounds on Parameters with\n        optim() C Interface","text":"fork libfgsb3 cran following differences: - return type changed similar optim returns - Allows direct C/C++ interface R registered function, similar C interface optim 2 additional arguments. - Allows adjustment tolerances minimization success. - Added xtolAtol xtolRtol minimization success criterion. - Added maxit termination","code":""},{"path":"https://nlmixr2.github.io/lbfgsb3c/reference/lbfgsb3c.html","id":null,"dir":"Reference","previous_headings":"","what":"Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver. — lbfgsb3c","title":"Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver. — lbfgsb3c","text":"Interfacing wrapper Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver.","code":""},{"path":"https://nlmixr2.github.io/lbfgsb3c/reference/lbfgsb3c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver. — lbfgsb3c","text":"","code":"lbfgsb3c(   par,   fn,   gr = NULL,   lower = -Inf,   upper = Inf,   control = list(),   ...,   rho = NULL )  lbfgsb3(   par,   fn,   gr = NULL,   lower = -Inf,   upper = Inf,   control = list(),   ...,   rho = NULL )  lbfgsb3f(   par,   fn,   gr = NULL,   lower = -Inf,   upper = Inf,   control = list(),   ...,   rho = NULL )  lbfgsb3x(   par,   fn,   gr = NULL,   lower = -Inf,   upper = Inf,   control = list(),   ...,   rho = NULL )"},{"path":"https://nlmixr2.github.io/lbfgsb3c/reference/lbfgsb3c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver. — lbfgsb3c","text":"par parameter vector gives initial guesses parameters minimize fn. can named, example, use par=c(b1=1, b2=2.345, b3=0.123) fn function evaluates objective function minimized.  can R function Rcpp function pointer. gr present, function evaluates gradient vector objective function given parameters computing elements sum squares function set parameters start. can R function Rcpp function pointer. lower Lower bounds parameters. single number, applied parameters. Default -Inf. upper Upper bounds parameters. single number, applied parameters. Default Inf. control optional list control settings. See details. ... data needed computation objective function gradient. rho Environment use function evaluation.  present arguments ... ignored.  Otherwise ... converted environment evaluation.","code":""},{"path":"https://nlmixr2.github.io/lbfgsb3c/reference/lbfgsb3c.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver. — lbfgsb3c","text":"list following items par best set parameters found. value value fn corresponding par. counts two-element integer vector giving number calls fn gr respectively. excludes calls fn compute finite-difference approximation gradient. convergence integer code. 0 indicates successful completion","code":""},{"path":"https://nlmixr2.github.io/lbfgsb3c/reference/lbfgsb3c.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver. — lbfgsb3c","text":"See notes general appreciation package. control list can contain: trace positive, tracing information progress optimization produced. Higher values may produce tracing information: method \"L-BFGS-B\" six levels tracing. (understand exactly see source code: higher levels give detail.) factr controls convergence \"L-BFGS-B\" method. Convergence occurs reduction objective within factor machine tolerance. Default 1e7, tolerance 1e-8. pgtol helps control convergence \"L-BFGS-B\" method. tolerance projected gradient current search direction. defaults zero, check suppressed. abstol helps control convergence \"L-BFGS-B\" method. absolute tolerance difference x values. defaults zero, check suppressed. reltol helps control convergence \"L-BFGS-B\" method. relative tolerance difference x values. defaults zero, check suppressed. lmm integer giving number BFGS updates retained \"L-BFGS-B\" method, defaults 5. maxit maximum number iterations. iprint Provided compatibility older codes. control longer active.) info boolean indicate optimization information captured output $info list","code":""},{"path":"https://nlmixr2.github.io/lbfgsb3c/reference/lbfgsb3c.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver. — lbfgsb3c","text":"package wrapper Fortran code released Nocedal Morales.   poses several difficulties R package. .Fortran()   tool exists interfacing, must careful align arguments   Fortran subroutine, especially type storage. annoying task interfacing Fortran code Fortran WRITE   PRINT statements must replaced calls special R-friendly output   routines. Unfortunately, Fortran full output statements. Worse, may   wish able suppress output, thus many modifications   made. means update original code simply   plugged R package src directory. Finally, likely L-BFGS-B long history, Fortran code far   well-structured. example, number function gradient evaluations   used returned 34'th element integer vector. appear   easy way stop program maximum number evaluations   performed. hand, version L-BFGS-B optim() C translation   now-lost Fortran code. implement improvements Nocedal   Morales published 2011. Hence, despite deficiencies, wrapper   prepared. addition reasons original lbfgsb3 package, additional package allows C calling L-BFGS-B 3.0 program well adjustments tolerances present original CRAN package.  Also adjustments made outputs conform R's optim routine.","code":""},{"path":"https://nlmixr2.github.io/lbfgsb3c/reference/lbfgsb3c.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver. — lbfgsb3c","text":"Morales, J. L.; Nocedal, J. (2011). \"Remark 'algorithm 778: L-BFGS-B:           Fortran subroutines large-scale bound constrained optimization' \".           ACM Transactions Mathematical Software 38: 1. Byrd, R. H.; Lu, P.; Nocedal, J.; Zhu, C. (1995). \"Limited Memory Algorithm           Bound Constrained Optimization\". SIAM J. Sci. Comput. 16 (5): 1190-1208. Zhu, C.; Byrd, Richard H.; Lu, Peihuang; Nocedal, Jorge (1997). \"L-BFGS-B:           Algorithm 778: L-BFGS-B, FORTRAN routines large scale bound constrained           optimization\". ACM Transactions Mathematical Software 23 (4): 550-560.","code":""},{"path":[]},{"path":"https://nlmixr2.github.io/lbfgsb3c/reference/lbfgsb3c.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver. — lbfgsb3c","text":"Matthew Fidler (move C add options adjustments),     John C Nash <nashjc@uottawa.ca> (wrapper edits Fortran code allow R output)     Ciyou Zhu, Richard Byrd, Jorge Nocedal, Jose Luis Morales (original Fortran packages)","code":""},{"path":"https://nlmixr2.github.io/lbfgsb3c/reference/lbfgsb3c.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver. — lbfgsb3c","text":"","code":"# Rosenbrock's banana function n=3; p=100  fr = function(x) {     f=1.0     for(i in 2:n) {         f=f+p*(x[i]-x[i-1]**2)**2+(1.0-x[i])**2     }     f }  grr = function(x) {     g = double(n)     g[1]=-4.0*p*(x[2]-x[1]**2)*x[1]     if(n>2) {         for(i in 2:(n-1)) {             g[i]=2.0*p*(x[i]-x[i-1]**2)-4.0*p*(x[i+1]-x[i]**2)*x[i]-2.0*(1.0-x[i])         }     }     g[n]=2.0*p*(x[n]-x[n-1]**2)-2.0*(1.0-x[n])     g } x = c(a=1.02, b=1.02, c=1.02) (opc <- lbfgsb3c(x,fr, grr)) #> $par #>        a        b        c  #> 1.000041 1.000083 1.000169  #>  #> $grad #>             a             b             c  #> -0.0002752393 -0.0006637576  0.0008213517  #>  #> $value #> [1] 1 #>  #> $counts #> [1] 21 21 #>  #> $convergence #> [1] 0 #>  #> $message #> [1] \"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH\" #>  (op <- lbfgsb3(x,fr, grr, control=list(trace=1))) #> At iteration 0 f=1.084032  #> At iteration 2 f=144.115766  #> At iteration 3 f=1.003318  #> At iteration 4 f=1.000877  #> At iteration 5 f=1.000876  #> At iteration 6 f=1.000866  #> At iteration 7 f=1.000863  #> At iteration 8 f=1.000853  #> At iteration 9 f=1.000707  #> At iteration 10 f=1.000295  #> At iteration 11 f=1.080517  #> At iteration 12 f=1.000158  #> At iteration 13 f=1.000142  #> At iteration 14 f=1.000088  #> At iteration 15 f=1.000277  #> At iteration 16 f=1.000033  #> At iteration 17 f=1.000001  #> At iteration 18 f=1.000000  #> At iteration 19 f=1.000000  #> At iteration 20 f=1.000000  #> At iteration 21 f=1.000000  #> $par #>        a        b        c  #> 1.000041 1.000083 1.000169  #>  #> $grad #>             a             b             c  #> -0.0002752393 -0.0006637576  0.0008213517  #>  #> $value #> [1] 1 #>  #> $counts #> [1] 21 21 #>  #> $convergence #> [1] 0 #>  #> $message #> [1] \"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH\" #>  #> $info #> $info$task #> [1] \"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH\" #>  #> $info$itask #> [1] 8 #>  #> $info$lsave #> [1] FALSE FALSE FALSE FALSE #>  #> $info$icsave #> [1] 6 #>  #> $info$dsave #>  [1]  1.170212e+03  1.000000e+00  2.220446e-09  1.634496e-06  2.220446e-16 #>  [6]  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 #> [11] -1.103432e-09  1.000000e+10  8.213517e-04  1.000000e+00 -1.411118e-09 #> [16]  2.671576e-12 -1.411118e-09 -1.411118e-12 -1.411118e-09 -1.411118e-09 #> [21]  1.000000e+00  1.000000e+00  1.000000e+00  0.000000e+00  0.000000e+00 #> [26]  0.000000e+00  5.000000e+00  1.000000e+10  2.000000e+10 #>  #> $info$isave #>  [1]  3  1  4  1  4  7  8  9 10 14 18 21 24 27 30 33  0  0  0  0  0  1  0  0  0 #> [26]  0  1  1  1 14 13  0  0 21  0  1  0  3  0  4  0  0  0  1 #>  #>  (opx <- lbfgsb3x(x,fr, grr)) #> $par #>        a        b        c  #> 1.000041 1.000083 1.000169  #>  #> $grad #>             a             b             c  #> -0.0002752393 -0.0006637576  0.0008213517  #>  #> $value #> [1] 1 #>  #> $counts #> [1] 21 21 #>  #> $convergence #> [1] 0 #>  #> $message #> [1] \"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH\" #>  (opf <- lbfgsb3f(x,fr, grr)) #> $par #>        a        b        c  #> 1.000041 1.000083 1.000169  #>  #> $grad #>             a             b             c  #> -0.0002752393 -0.0006637576  0.0008213517  #>  #> $value #> [1] 1 #>  #> $counts #> [1] 21 21 #>  #> $convergence #> [1] 0 #>  #> $message #> [1] \"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH\" #>  #> $info #> $info$task #> [1] \"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH\" #>  #> $info$itask #> [1] 8 #>  #> $info$lsave #> [1] FALSE FALSE FALSE FALSE #>  #> $info$icsave #> [1] 6 #>  #> $info$dsave #>  [1]  1.170212e+03  1.000000e+00  2.220446e-09  1.634496e-06  2.220446e-16 #>  [6]  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 #> [11] -1.103432e-09  1.000000e+10  8.213517e-04  1.000000e+00 -1.411118e-09 #> [16]  2.671576e-12 -1.411118e-09 -1.411118e-12 -1.411118e-09 -1.411118e-09 #> [21]  1.000000e+00  1.000000e+00  1.000000e+00  0.000000e+00  0.000000e+00 #> [26]  0.000000e+00  5.000000e+00  1.000000e+10  2.000000e+10 #>  #> $info$isave #>  [1]  3  1  4  1  4  7  8  9 10 14 18 21 24 27 30 33  0  0  0  0  0  1  0  0  0 #> [26]  0  1  1  1 14 13  0  0 21  0  1  0  3  0  4  0  0  0  1 #>  #>"}]
